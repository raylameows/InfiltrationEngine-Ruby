<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXB7E82596D2F740ACA6F8AF8772919567">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">Ruby</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX5D2DC570EBE9421E88D5EE24D2689110">
			<Properties>
				<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local RayUtil = require(`./RayUtil`)
local Ruby = require(`./Ruby`)
Ruby.Plugin = plugin

local Toolbar = plugin:CreateToolbar("Ruby")
local Button = Toolbar:CreateButton(`Ruby`, `Fetches the most recent serializer from the Github and automatically adds itself as a plugin`, `rbxassetid://92473074743015`)
Ruby.Button = Button

local PluginsFolder = RayUtil.getFolder(ReplicatedStorage, `Plugins`, true)
local RubyPluginFolder = PluginsFolder and RayUtil.getFolder(PluginsFolder, `Ruby`, true)
local CachedExporter = RubyPluginFolder and RubyPluginFolder:FindFirstChild(`SerializationTools`)
if CachedExporter then
	Ruby.backgroundChecks(true)
end
Ruby.RubyPluginFolder = RubyPluginFolder

local deb = false
Button.Click:Connect(function()
	if deb then return end
	PluginsFolder = RayUtil.getFolder(ReplicatedStorage, `Plugins`)
	RubyPluginFolder = RayUtil.getFolder(PluginsFolder, `Ruby`)
	CachedExporter = RubyPluginFolder:FindFirstChild(`SerializationTools`)
	Ruby.RubyPluginFolder = RubyPluginFolder
	
	if not CachedExporter then
		deb = true
		Ruby.fetch(RubyPluginFolder)
		task.wait()
		deb = false
		return
	elseif CachedExporter and not Ruby.Exporter then
		deb = true
		Ruby.hookAttributeChanges(CachedExporter, RubyPluginFolder)
		Ruby.Root = CachedExporter
		Ruby.Exporter = require(CachedExporter.Writing.Main)
		task.wait()
		deb = false
	end
	
	if not Ruby.Active then
		Ruby.Active = true
		plugin:Activate(true)
		Ruby.Exporter.Init(plugin:GetMouse())
		Ruby.getFetchSourceButton()
		Ruby.updateStatus()
		local button: TextButton = Ruby.FetchSourceButton
		if button then
			local lastClickTime = 0
			local doubleClickThreshold = 0.3

			button.Activated:Connect(function()
				local currentTime = tick()
				if currentTime - lastClickTime <= doubleClickThreshold then
					print("Ruby :: Performing refetch")
					CachedExporter:SetAttribute("Refetch", true)
				else
					task.delay(doubleClickThreshold, function()
						if tick() - lastClickTime >= doubleClickThreshold then
							print("Ruby :: Performing update check")
							local outdated = Ruby.checkForUpdate(true)
							if outdated == false then
								print("Ruby :: Serializer is up to date")
							elseif outdated == true then
								print("Ruby :: Serializer is outdated")
							end
						end
					end)
				end

				lastClickTime = currentTime
			end)
		end
	else
		Ruby.Active = false
		plugin:Deactivate()
	end
end)

local function Disable()
	if Ruby.Exporter then
		Ruby.Exporter.Clean()
	end
	if Ruby.FetchSourceButton then
		Ruby.FetchSourceButton = nil
	end
	Ruby.Active = false
end

local function Unload()
	Disable()
end

plugin.Unloading:Connect(Unload)
plugin.Deactivation:Connect(Disable)]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{8b268a70-c52c-4efc-b66c-59a475d1b1fd}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Main</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX5C2D892BA90B4D95AD67B6E0B1313FC3">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local GithubLoader = {}
GithubLoader.FileTypeToInstance = {
	[`dir`] = `Folder`,
	[`file.server.lua`] = `Script`,
	[`file.lua`] = `ModuleScript`,
}

function GithubLoader.toProxy(url: string)
	local pattern = "^https://raw%.githubusercontent%.com/([^/]+)/([^/]+)/([^/]+)/(.*)$"
	local user, repo, branch, path = url:match(pattern)

	if not (user and repo and branch and path) then
		warn(`GithubLoader :: Invalid url {url}`)
		return nil
	end

	local jsDelivrUrl = ("https://cdn.jsdelivr.net/gh/%s/%s@%s/%s"):format(user, repo, branch, path)
	return jsDelivrUrl
end

function GithubLoader.call(holder: Folder, url: string)
	holder:SetAttribute(`RequestsProcessing`, holder:GetAttribute(`RequestsProcessing`) + 1)
	local success, response = pcall(function()
		return HttpService:GetAsync(url)
	end)
	
	holder:SetAttribute(`RequestsProcessing`, holder:GetAttribute(`RequestsProcessing`) - 1)
	holder:SetAttribute(`LastProcessed`, tick())
	return success, response
end

function GithubLoader.dir(holder: Folder, folder: Folder, url: string)
	print(`GithubLoader :: Loading {url}`)
	folder = folder or holder
	
	local success, response = GithubLoader.call(holder, url)
	if not success then warn(`GithubLoader :: {response}`) return end
	
	local files = HttpService:JSONDecode(response)
	local currentBatch = 0
	for _, fileData in (files) do
		local split = string.split(fileData.name, `.`)
		local key = `{fileData.type}{split[2] and `.{split[2]}` or ``}{#split >= 3 and `.{split[3]}` or ``}`
		local obj = Instance.new(GithubLoader.FileTypeToInstance[key])
		obj.Name = split[1]
		obj.Parent = folder

		if fileData.type == `dir` then
			task.spawn(function()
				GithubLoader.dir(holder, obj, fileData.url)
			end)
		elseif fileData.download_url then
			task.spawn(function()
				local success, response = GithubLoader.call(holder, GithubLoader.toProxy(fileData.download_url))
				if not success then warn(`GithubLodaer :: {response}`) return end
				obj.Source = response
			end)
		end
	end
end

function GithubLoader.repo(url: string, name: string?, yield: boolean?)
	local folder = Instance.new(`Folder`)
	folder.Name = name or `RubySerializerFolder`
	folder:SetAttribute(`RequestsProcessing`, 0)
	folder:SetAttribute(`LastProcessed`, tick())
	folder.Parent = ReplicatedStorage
	
	GithubLoader.dir(folder, nil, url)
	
	if yield and folder:GetAttribute(`RequestsProcessing`) then
		repeat task.wait() until folder:GetAttribute(`RequestsProcessing`) == 0 and tick() - folder:GetAttribute(`LastProcessed`) >= 1
	end
	
	return folder
end

return GithubLoader]]></ProtectedString>
				<string name="ScriptGuid">{b106303e-9483-3906-5006-95dd9611cf5c}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">GithubLoader</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXF5B9DB0A08544A93BBE7CD78FA850C93">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")

local GithubLoader = require(`./GithubLoader`)

local Ruby = {}
Ruby.RubyPluginFolder = nil
Ruby.Button = nil
Ruby.Exporter = nil
Ruby.Root = nil
Ruby.FetchSourceButton = nil
Ruby.BackgroundChecks = false
Ruby.Outdated = false
Ruby.LoadingIDs = {
	138016358530888, 70597296726422, 127832681223670, 83695390279728, 133089274035459, 84382514433800, 
	78784862813485, 112194325401656, 139036767631117, 102076830057398, 131568282874164
}

function Ruby.backgroundChecks(enabled: boolean)
	if Ruby.BackgroundChecks == enabled then return end
	
	Ruby.BackgroundChecks = enabled
	if Ruby.BackgroundChecks then
		task.spawn(function()
			while Ruby.BackgroundChecks do
				task.wait(10*60)
				if not Ruby.BackgroundChecks then break end
				Ruby.checkForUpdate()
			end
		end)
	end
end

function Ruby.checkForUpdate(noPrint: boolean?)
	if (not Ruby.Root or not Ruby.Root.Parent) then 
		Ruby.backgroundChecks(false) 
		return nil
	end
	
	local recent = Ruby.getLatestUpdate(Ruby.Root)
	if recent == nil then return nil end
	
	if recent ~= Ruby.Root:GetAttribute(`Date`) then
		if not Ruby.Outdated and not noPrint then
			warn(`Ruby :: Detected new SerializationTools commit`)
		end
		Ruby.Outdated = true
		Ruby.updateStatus()
		return true
	end
	
	return false
end

function Ruby.updateStatus()
	if Ruby.FetchSourceButton then
		Ruby.FetchSourceButton.BackgroundColor3 = Ruby.Outdated and Color3.fromRGB(255, 38, 52) or Color3.fromRGB(0, 0, 0)
	end
end

function Ruby.getFetchSourceButton()
	local possible = CollectionService:GetTagged(`RubySerializerFetchSourceButton`)
	for _,button in (possible) do
		if button:IsA(`TextButton`) and button.Text == `Fetch Source` and button:IsDescendantOf(CoreGui) then
			Ruby.FetchSourceButton = button
			return button
		end
	end
	
	return nil
end

function Ruby.getLatestUpdate(serializer: Folder)
	local success, data = GithubLoader.call(
		serializer,
		`https://api.github.com/repos/MoonstoneSkies/InfiltrationEngine-Custom-Missions/commits?path=Plugins/src/SerializationTools&per_page=1`
	)
	if not success then warn(`Ruby :: Checking SerializationTools failed {data}`) return end
	data = HttpService:JSONDecode(data)

	local lastUpdate = data[1].commit.committer.date
	return lastUpdate
end

function Ruby.fetch(cache: Folder)
	local loaded = false do
		task.spawn(function()
			local prevImg = Ruby.Button.Icon
			while not loaded do
				for i,v in (Ruby.LoadingIDs) do
					Ruby.Button.Icon = `rbxassetid://{v}`
					task.wait(0.08)
				end
			end
			Ruby.Button.Icon = prevImg
		end)
	end

	local folder = workspace:FindFirstChild(`SerializationToolsDebug`) and workspace.SerializationToolsDebug:Clone() or GithubLoader.repo(
		`https://api.github.com/repos/MoonstoneSkies/InfiltrationEngine-Custom-Missions/contents/Plugins/src/SerializationTools`, 
		`SerializationTools`, 
		true
	)
	if not folder:GetAttribute(`RequestsProcessing`) then
		folder:SetAttribute(`RequestsProcessing`, 0)
	end

	folder.Name = `SerializationTools`
	folder.Parent = cache

	local mainWriting = folder:FindFirstChild(`Writing`) and folder.Writing:FindFirstChild(`Main`)
	if not mainWriting then 
		warn(`Ruby :: Main/Writing.lua is missing`) 
		loaded = true
		folder:Destroy()
		return 
	end

	Ruby.Root = folder
	folder:SetAttribute(`Date`, `recent`)
	task.spawn(function()
		folder:SetAttribute(`Date`, Ruby.getLatestUpdate(folder))
	end)

	local injections = {
		[`local%s+readbackEnabled%s*=%s*FeatureCheck%("Readback"%)%s*==%s*true`] = 
		[[
		local fetchSourceButton = Button({
			Size = UDim2.new(0, 200, 0, 30),
			Enabled = module.EnabledState,
			Position = UDim2.new(0, apiDevEnabled and 270 or 50, 1, -50),
			AnchorPoint = Vector2.new(0, 1),
			Text = `Fetch Source`,
		})
		fetchSourceButton:AddTag(`RubySerializerFetchSourceButton`)
		]],

		[`(%s*Create%(%\"ScrollingFrame\"%s*,)`] = 
		[[
		fetchSourceButton,
		]],
	}
	local modified = mainWriting.Source
	for pattern,inject in (injections) do
		modified = modified:gsub(pattern, inject .. `\n%1`, 1)
	end
	mainWriting.Source = modified
	task.wait(0.5)
	Ruby.hookAttributeChanges(folder, cache)
	if Ruby.Exporter then Ruby.Exporter.Clean() end
	Ruby.Exporter = require(mainWriting)
	task.wait(0.5)
	loaded = true
	Ruby.backgroundChecks(true)
end

function Ruby.hookAttributeChanges(folder: Folder, cache: Folder)
	folder:GetAttributeChangedSignal(`Refetch`):Connect(function()
		local nv = folder:GetAttribute(`Refetch`)
		folder:SetAttribute(`Refetch`, nil)

		if nv then
			Ruby.Active = false
			Ruby.Plugin:Deactivate()
			folder:Destroy()
			Ruby.fetch(cache)
		end
	end)
	
	folder:GetAttributeChangedSignal(`NoBackgroundChecks`):Connect(function()
		local nv = folder:GetAttribute(`NoBackgroundChecks`)
		if nv == true then
			Ruby.backgroundChecks(false)
		else
			Ruby.backgroundChecks(true)
		end
	end)
end

return Ruby]]></ProtectedString>
				<string name="ScriptGuid">{a6eecf96-7338-5585-db79-0e702a348b5a}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Ruby</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXBDC2B87DDCFD4A2E9C13FFA7F2F8A604">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local RayUtil = {}

-- Gets a folder from the designated parent, or creates one if necessary
function RayUtil.getFolder(parent: Instance, name: string, optional: boolean)
	local folder = parent:FindFirstChild(name)
	if not folder and not optional then
		folder = Instance.new(`Folder`)
		folder.Name = name
		folder.Parent = parent
	end

	return folder
end

return RayUtil]]></ProtectedString>
				<string name="ScriptGuid">{d406c0eb-bf18-709d-2972-610e2ed64765}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">RayUtil</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>